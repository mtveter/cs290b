package util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

public class TspBounds {
	
	public static HashMap<Integer, ArrayList<Integer>> lbAdjacencyMap = new HashMap<Integer, ArrayList<Integer>>();
	public static Double currentMstCost;
	
	
	public static double computeUpperBound(List<Integer> cityIdList, double[][] distances){
		double result = 0;
		
		// Visited cities
		List<Integer> visited = new ArrayList<Integer>();
		// Unvisited cities
		List<Integer> unvisited = new ArrayList<Integer>(cityIdList);
		
		Integer cityToVisit = unvisited.get(0);
		unvisited.remove(0);
		visited.add(cityToVisit);
		
		int counter = cityIdList.size();
		while(counter > 1){
			
			double shortestDistance = 0;
			int cityToVisitNum = 0;
			Integer tempCityToVisit = null;
			for(int i = 0; i < unvisited.size(); i++){
				if(shortestDistance == 0){
					shortestDistance = distances[cityToVisit][unvisited.get(i)];
					tempCityToVisit = unvisited.get(i);
					cityToVisitNum = i;
				}
				else{
					double tempDistance = distances[cityToVisit][unvisited.get(i)];
					if(tempDistance < shortestDistance) {
						shortestDistance = tempDistance;
						tempCityToVisit = unvisited.get(i);
						cityToVisitNum = i;
					}
				}
			}
			unvisited.remove(cityToVisitNum);
			visited.add(tempCityToVisit);
			cityToVisit = tempCityToVisit;
			
			result += shortestDistance;
			
			counter--;
		}
		Integer startCity = visited.get(0);
		Integer endCity = visited.get(visited.size() - 1);
		// Add Cost from last city in tour to start city
		result += distances[startCity][endCity];
		
		return result;
	}
	
	/**
	 * Calculates the lower
	 * @param newMst				true if a new mst needs to be computed
	 * @param city 					Start node in TSP problem
	 * @param cityIdentifierList	List of identifier of all cities in subproblem
	 * @param cities				Array of all distances between cities in the multi-graph
	 * @return	The total value of the lower bound
	 */
	public static double computeLowerBound(boolean newMst, Integer firstLocked, Integer startCityId, List<Integer> cityIdentifierList, double[][] distances) {
		double result = 0; 
		if(cityIdentifierList.size() < 2) {
			System.out.println("There has to be atleast 2 cities to find a lowerbound with a MST");
			return result;
		}
		if(startCityId.equals(0)) {
			int n = 16;
			for (int v = 0; v < n; v++) {
				lbAdjacencyMap.put(v, new ArrayList<Integer>());
			}
		}
		// 
		if(newMst) {
			// Returns total cost of minimal cost spanning tree generated by Prim's algorithm
			double mstCost = primsMstCost(cityIdentifierList, distances);
			result += mstCost;
		}
		else {
			result += TspBounds.currentMstCost;
		}
		
		/* Find two cities with minimum distance to start city */
//		double[] distanceToStartList = new double[cityIdentifierList.size()];
//		for(int i = 0; i < cityIdentifierList.size(); i++) {
//			int cityId = (int) cityIdentifierList.get(i);
//			int tempStartCityId = (int) startCityId;
//			double tempDistance = distances[tempStartCityId][cityId];
//			distanceToStartList[i] = tempDistance;
//		}
//		Arrays.sort(distanceToStartList);
//		
////		Adds the cost of the two cities closest to starting city
//		result += distanceToStartList[0];
//		result += distanceToStartList[1];
		
		double shortestDistance1 = 0;
		for(int i = 0; i < cityIdentifierList.size(); i++) {
			int cityId = (int) cityIdentifierList.get(i);
			int tempStartCityId = (int) firstLocked;
			double tempDistance = distances[tempStartCityId][cityId];
			if(tempDistance < shortestDistance1 || shortestDistance1 == 0) {
				shortestDistance1 = tempDistance;
			}
		}
		
		double shortestDistance2 = 0;
		for(int i = 0; i < cityIdentifierList.size(); i++) {
			int cityId = (int) cityIdentifierList.get(i);
			int tempStartCityId = (int) startCityId;
			double tempDistance = distances[tempStartCityId][cityId];
			if(tempDistance < shortestDistance2 || shortestDistance2 == 0) {
				shortestDistance2 = tempDistance;
			}
		}
		result += shortestDistance1;
		result += shortestDistance2;	
	
		return result;
	}
	
	public static void removeCityFromMst(Integer num, Integer city, double[][] distances) {
		if(num == 1) {
			Integer neighbor = lbAdjacencyMap.get(city).get(0);
			lbAdjacencyMap.get(neighbor).remove(new Integer(city));
			lbAdjacencyMap.get(city).clear();
			
			currentMstCost -= distances[city][neighbor];
		}
		else if(num == 2) {
			Integer neighbor1 = lbAdjacencyMap.get(city).get(0);
			Integer neighbor2 = lbAdjacencyMap.get(city).get(1);
			
			lbAdjacencyMap.get(neighbor1).remove(new Integer(city));
			lbAdjacencyMap.get(neighbor1).add(neighbor2);
			
			lbAdjacencyMap.get(neighbor2).remove(new Integer(city));
			lbAdjacencyMap.get(neighbor2).add(neighbor1);
			
			lbAdjacencyMap.get(city).clear();
			
			currentMstCost -= distances[city][neighbor1];
			currentMstCost -= distances[city][neighbor2];

			currentMstCost += distances[neighbor1][neighbor2];
		}
	}
	
	private static double primsMstCost(List<Integer> cityIdList, double[][] distances)  {
		double costOfMst = 0;
		// Visited cities
		List<Integer> visited = new ArrayList<Integer>();
		// Unvisited cities
		List<Integer> unvisited = new ArrayList<Integer>(cityIdList);
		
		Integer cityStart = unvisited.get(0);
		unvisited.remove(0);
		visited.add(cityStart);
		
		int counter = cityIdList.size();
		while(counter > 1){
			printList(visited, unvisited);
			
			double shortestDistance = 0;
			int cityToVisitNum = 0;
			Integer tempCityToVisit = null;
			Integer tempCityFromVisited = null;
			
			// Double loop to check all visited cities paths to all unvisited cities
			for(int  i = 0; i < visited.size(); i++) {
				Integer cityFrom = visited.get(i);
				
				for(int  j = 0; j < unvisited.size(); j++) {
					Integer cityTo = unvisited.get(j);
					
					
					if(shortestDistance == 0){
						tempCityFromVisited = new Integer(cityFrom);
						shortestDistance = distances[cityFrom][cityTo];
						tempCityToVisit = unvisited.get(j);
						cityToVisitNum = i;
					}
					else{
						double tempDistance = distances[cityFrom][cityTo];
					
						if(tempDistance < shortestDistance) {
							tempCityFromVisited = new Integer(cityFrom);
							shortestDistance = tempDistance;
							tempCityToVisit = unvisited.get(j);
							cityToVisitNum = j;
						}
					}
				}
			}
			unvisited.remove(cityToVisitNum);
			//System.out.println("City TO VISIT: " + tempCityToVisit);
			visited.add(tempCityToVisit);
			
			lbAdjacencyMap.get(tempCityToVisit).add(tempCityFromVisited);
			lbAdjacencyMap.get(tempCityFromVisited).add(tempCityToVisit);
			
			costOfMst += shortestDistance;
			
			counter--;
		}
		currentMstCost = costOfMst;
		
		return costOfMst;
	}
	
	private static void printList(List<Integer> l1, List<Integer> l2) {
		
	}
}
