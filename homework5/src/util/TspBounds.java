package util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class TspBounds {
	/**
	 * Calculates the lower
	 * @param city 					Start node in TSP problem
	 * @param cityIdentifierList	List of identifier of all cities in subproblem
	 * @param cities				
	 * @return	The total value of the lower bound
	 */
	public static double computeLowerBound(Integer startCityId, List<Integer> cityIdentifierList, double[][] distances) {
		double result = 0; 
		if(cityIdentifierList.size() < 2) {
			System.out.println("There has to be atleast 2 cities to find a lowerbound with a MST");
			return result;
		}
		// Returns total cost of minimal cost spanning tree generated by Prim's algorithm
		result += primsMstCost(cityIdentifierList, distances);
		
		/* Find two cities with minimum distance to start city */
		double[] distanceToStartList = new double[cityIdentifierList.size()];
		for(int i = 0; i < cityIdentifierList.size(); i++) {
			int cityId = (int) cityIdentifierList.get(i);
			int tempStartCityId = (int) startCityId;
			double tempDistance = distances[tempStartCityId][cityId];
			distanceToStartList[i] = tempDistance;
		}
		Arrays.sort(distanceToStartList);
		
		// Adds the cost of the two cities closest to starting city
		result += distanceToStartList[0];
		result += distanceToStartList[1];
		
		return result;
	}
	
	private static double primsMstCost(List<Integer> cityIndentifierList, double[][] distances)  {
		double costOfMst = 0;
		// Visited cities
		List<Integer> visited = new ArrayList<Integer>();
		// Unvisited cities
		List<Integer> unvisited = new ArrayList<Integer>(cityIndentifierList);
		int counter = cityIndentifierList.size();
		while(counter > 1){
			int tempCity = (int) unvisited.remove(0);
			visited.add(tempCity);
			
			double shortestDistance = 0; 
			for(int i = 0; i < unvisited.size(); i++){
				if(shortestDistance == 0){
					shortestDistance = unvisited.get(i);
				}
				else{
					double tempDistance = unvisited.get(i);
					if(tempDistance < shortestDistance) {
						shortestDistance = tempDistance;
					}
				}
			}
			costOfMst += shortestDistance;
			
			counter--;
		}
		
		return costOfMst;
	}
}
